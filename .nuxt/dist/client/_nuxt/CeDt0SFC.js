import{g as C,r as y,s as b,h as w,i as B,j as O,k as M,l as m,m as E,n as x,q as z,v as H,x as R,y as S,o as j,c as N,a as K}from"./CWesRufG.js";const T=s=>s==="defer"||s===!1;function $(...s){var D;const r=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(r);let[e,u,a={}]=s;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=E(),p=u,v=()=>null,g=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??v,a.getCachedData=a.getCachedData??g,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??C.deep,a.dedupe=a.dedupe??"cancel";const d=()=>a.getCachedData(e,t)!=null;if(!t._asyncData[e]||!a.immediate){(D=t.payload._errors)[e]??(D[e]=null);const c=a.deep?y:b;t._asyncData[e]={data:c(a.getCachedData(e,t)??a.default()),pending:y(!d()),error:w(t.payload._errors,e),status:y("idle")}}const n={...t._asyncData[e]};n.refresh=n.execute=(c={})=>{if(t._asyncDataPromises[e]){if(T(c.dedupe??a.dedupe))return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if((c._initial||t.isHydrating&&c._initial!==!1)&&d())return Promise.resolve(a.getCachedData(e,t));n.pending.value=!0,n.status.value="pending";const l=new Promise((i,o)=>{try{i(p(t))}catch(f){o(f)}}).then(async i=>{if(l.cancelled)return t._asyncDataPromises[e];let o=i;a.transform&&(o=await a.transform(i)),a.pick&&(o=F(o,a.pick)),t.payload.data[e]=o,n.data.value=o,n.error.value=null,n.status.value="success"}).catch(i=>{if(l.cancelled)return t._asyncDataPromises[e];n.error.value=x(i),n.data.value=z(a.default()),n.status.value="error"}).finally(()=>{l.cancelled||(n.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=l,t._asyncDataPromises[e]},n.clear=()=>q(t,e);const h=()=>n.refresh({_initial:!0}),P=a.server!==!1&&t.payload.serverRendered;{const c=H();if(c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const o=c._nuxtOnBeforeMountCbs;B(()=>{o.forEach(f=>{f()}),o.splice(0,o.length)}),O(()=>o.splice(0,o.length))}P&&t.isHydrating&&(n.error.value||d())?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):c&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?c._nuxtOnBeforeMountCbs.push(h):a.immediate&&h();const l=R();if(a.watch){const o=M(a.watch,()=>n.refresh());l&&m(o)}const i=t.hook("app:data:refresh",async o=>{(!o||o.includes(e))&&await n.refresh()});l&&m(i)}const _=Promise.resolve(t._asyncDataPromises[e]).then(()=>n);return Object.assign(_,n),_}function q(s,r){r in s.payload.data&&(s.payload.data[r]=void 0),r in s.payload._errors&&(s.payload._errors[r]=null),s._asyncData[r]&&(s._asyncData[r].data.value=void 0,s._asyncData[r].error.value=null,s._asyncData[r].pending.value=!1,s._asyncData[r].status.value="idle"),r in s._asyncDataPromises&&(s._asyncDataPromises[r].cancelled=!0,s._asyncDataPromises[r]=void 0)}function F(s,r){const e={};for(const u of r)e[u]=s[u];return e}const I=K("h1",{class:"text-rose-500"},"About page",-1),U=[I],W=S({__name:"about",setup(s){const{data:r}=$(()=>$fetch("http://localhost:3000"),"$DWlCMkxhze");return console.log(r.value),(e,u)=>(j(),N("div",null,U))}});export{W as default};
